// ************************************************************************ //
// WARNING                                                                    
// -------                                                                    
// The types declared in this file were generated from data read from a       
// Type Library. If this type library is explicitly or indirectly (via        
// another type library referring to this type library) re-imported, or the   
// 'Refresh' command of the Type Library Editor activated while editing the   
// Type Library, the contents of this file will be regenerated and all        
// manual modifications will be lost.                                         
// ************************************************************************ //

// C++ TLBWRTR : $Revision:   1.151.1.0.1.27  $
// File generated on 2010/9/12 21:28:53 from Type Library described below.

// ************************************************************************  //
// Type Lib: C:\Windows\System32\MSCOMM32.OCX (1)
// LIBID: {648A5603-2C6E-101B-82B6-000000000014}
// LCID: 0
// Helpfile: C:\Windows\System32\COMM98.CHM
// HelpString: Microsoft Comm Control 6.0
// DepndLst: 
//   (1) v2.0 stdole, (C:\Windows\system32\stdole2.tlb)
// ************************************************************************ //
#ifndef   MSCommLib_TLBH
#define   MSCommLib_TLBH

#pragma option push -b -w-inl

#include <utilcls.h>
#if !defined(__UTILCLS_H_VERSION) || (__UTILCLS_H_VERSION < 0x0600)
//
// The code generated by the TLIBIMP utility or the Import|TypeLibrary 
// and Import|ActiveX feature of C++Builder rely on specific versions of
// the header file UTILCLS.H found in the INCLUDE\VCL directory. If an 
// older version of the file is detected, you probably need an update/patch.
//
#error "This file requires a newer version of the header UTILCLS.H" \
       "You need to apply an update/patch to your copy of C++Builder"
#endif
#include <olectl.h>
#include <ocidl.h>
#if defined(USING_ATLVCL) || defined(USING_ATL)
#if !defined(__TLB_NO_EVENT_WRAPPERS)
#include <atl/atlmod.h>
#endif
#endif


// *********************************************************************//
// Forward reference of some VCL types (to avoid including STDVCL.HPP)    
// *********************************************************************//
namespace Stdvcl {class IStrings; class IStringsDisp;}
using namespace Stdvcl;
typedef TComInterface<IStrings> IStringsPtr;
typedef TComInterface<IStringsDisp> IStringsDispPtr;

namespace Mscommlib_tlb
{

// *********************************************************************//
// HelpString: Microsoft Comm Control 6.0
// Version:    1.1
// *********************************************************************//


// *********************************************************************//
// GUIDS declared in the TypeLibrary. Following prefixes are used:        
//   Type Libraries     : LIBID_xxxx                                      
//   CoClasses          : CLSID_xxxx                                      
//   DISPInterfaces     : DIID_xxxx                                       
//   Non-DISP interfaces: IID_xxxx                                        
// *********************************************************************//
extern __declspec (package) const GUID LIBID_MSCommLib;
extern __declspec (package) const GUID GUID_HandshakingConstants;
extern __declspec (package) const GUID GUID_HandshakeConstants;
extern __declspec (package) const GUID GUID_ErrorConstants;
extern __declspec (package) const GUID GUID_CommEventConstants;
extern __declspec (package) const GUID GUID_OnCommConstants;
extern __declspec (package) const GUID GUID_InputModeConstants;
extern __declspec (package) const GUID IID_IMSComm;
extern __declspec (package) const GUID DIID_DMSCommEvents;
extern __declspec (package) const GUID CLSID_MSComm;

// *********************************************************************//
// Forward declaration of types defined in TypeLibrary                    
// *********************************************************************//
enum      HandshakingConstants;
enum      HandshakeConstants;
enum      ErrorConstants;
enum      CommEventConstants;
enum      OnCommConstants;
enum      InputModeConstants;
interface DECLSPEC_UUID("{E6E17E90-DF38-11CF-8E74-00A0C90F26F8}") IMSComm;
typedef TComInterface<IMSComm, &IID_IMSComm> IMSCommPtr;

interface DECLSPEC_UUID("{648A5602-2C6E-101B-82B6-000000000014}") DMSCommEvents;
typedef TComInterface<DMSCommEvents, &DIID_DMSCommEvents> DMSCommEventsPtr;


// *********************************************************************//
// Declaration of CoClasses defined in Type Library                       
// (NOTE: Here we map each CoClass to its Default Interface)              
//                                                                        
// The LIBID_OF_ macro(s) map a LIBID_OF_CoClassName to the GUID of this  
// TypeLibrary. It simplifies the updating of macros when CoClass name    
// change.                                                                
// *********************************************************************//
typedef IMSComm MSComm;
typedef IMSCommPtr MSCommPtr;

#define LIBID_OF_MSComm (&LIBID_MSCommLib)

// *********************************************************************//
// Declaration of Enumerations defined in Type Library                    
// *********************************************************************//
typedef enum HandshakingConstants
{
  NoHandshaking = 0, 
  XonXoff = 1, 
  RtsCts = 2, 
  XonXoffAndRtsCts = 3
} HandshakingConstants;

typedef enum HandshakeConstants
{
  comNone = 0, 
  comXOnXoff = 1, 
  comRTS = 2, 
  comRTSXOnXOff = 3
} HandshakeConstants;

typedef enum ErrorConstants
{
  comInvalidPropertyValue = 380, 
  comGetNotSupported = 394, 
  comSetNotSupported = 383, 
  comPortInvalid = 8002, 
  comPortAlreadyOpen = 8005, 
  comPortOpen = 8000, 
  comNoOpen = 8012, 
  comSetCommStateFailed = 8015, 
  comPortNotOpen = 8018, 
  comReadError = 8020, 
  comDCBError = 8021, 
  comBreak = 1001, 
  comCTSTO = 1002, 
  comDSRTO = 1003, 
  comFrame = 1004, 
  comOverrun = 1006, 
  comCDTO = 1007, 
  comRxOver = 1008, 
  comRxParity = 1009, 
  comTxFull = 1010, 
  comDCB = 1011
} ErrorConstants;

typedef enum CommEventConstants
{
  comEventBreak = 1001, 
  comEventCTSTO = 1002, 
  comEventDSRTO = 1003, 
  comEventFrame = 1004, 
  comEventOverrun = 1006, 
  comEventCDTO = 1007, 
  comEventRxOver = 1008, 
  comEventRxParity = 1009, 
  comEventTxFull = 1010, 
  comEventDCB = 1011
} CommEventConstants;

typedef enum OnCommConstants
{
  comEvSend = 1, 
  comEvReceive = 2, 
  comEvCTS = 3, 
  comEvDSR = 4, 
  comEvCD = 5, 
  comEvRing = 6, 
  comEvEOF = 7
} OnCommConstants;

typedef enum InputModeConstants
{
  comInputModeText = 0, 
  comInputModeBinary = 1
} InputModeConstants;

// *********************************************************************//
// Interface: IMSComm
// Flags:     (4560) Hidden Dual NonExtensible OleAutomation Dispatchable
// GUID:      {E6E17E90-DF38-11CF-8E74-00A0C90F26F8}
// *********************************************************************//
interface IMSComm  : public IDispatch
{
public:
  // [1] Determines whether the carrier is present by querying the state of the Carrier Detect line.
  virtual HRESULT STDMETHODCALLTYPE set_CDHolding(VARIANT_BOOL pfCDHolding/*[in]*/) = 0;
  // [1] Determines whether the carrier is present by querying the state of the Carrier Detect line.
  virtual HRESULT STDMETHODCALLTYPE get_CDHolding(VARIANT_BOOL* pfCDHolding/*[out,retval]*/) = 0;
  // [2] Returns/sets the maximum amount of time the control waits for the Carrier Detect signal before timing out.
  virtual HRESULT STDMETHODCALLTYPE set_CDTimeout(long plCDTimeout/*[in]*/) = 0;
  // [2] Returns/sets the maximum amount of time the control waits for the Carrier Detect signal before timing out.
  virtual HRESULT STDMETHODCALLTYPE get_CDTimeout(long* plCDTimeout/*[out,retval]*/) = 0;
  // [3] Returns a handle that identifies the communications device.
  virtual HRESULT STDMETHODCALLTYPE set_CommID(long plCommID/*[in]*/) = 0;
  // [3] Returns a handle that identifies the communications device.
  virtual HRESULT STDMETHODCALLTYPE get_CommID(long* plCommID/*[out,retval]*/) = 0;
  // [4] Returns/sets the communications port number.
  virtual HRESULT STDMETHODCALLTYPE set_CommPort(short psCommPort/*[in]*/) = 0;
  // [4] Returns/sets the communications port number.
  virtual HRESULT STDMETHODCALLTYPE get_CommPort(short* psCommPort/*[out,retval]*/) = 0;
  virtual HRESULT STDMETHODCALLTYPE set__CommPort(short psCommPort/*[in]*/) = 0; // [0]
  virtual HRESULT STDMETHODCALLTYPE get__CommPort(short* psCommPort/*[out,retval]*/) = 0; // [0]
  // [5] Determines whether you can send data by querying the state of the Clear To Send line.
  virtual HRESULT STDMETHODCALLTYPE set_CTSHolding(VARIANT_BOOL pfCTSHolding/*[in]*/) = 0;
  // [5] Determines whether you can send data by querying the state of the Clear To Send line.
  virtual HRESULT STDMETHODCALLTYPE get_CTSHolding(VARIANT_BOOL* pfCTSHolding/*[out,retval]*/) = 0;
  // [6] Sets/returns the number of milliseconds to wait for the Clear To Send signal.
  virtual HRESULT STDMETHODCALLTYPE set_CTSTimeout(long plCTSTimeout/*[in]*/) = 0;
  // [6] Sets/returns the number of milliseconds to wait for the Clear To Send signal.
  virtual HRESULT STDMETHODCALLTYPE get_CTSTimeout(long* plCTSTimeout/*[out,retval]*/) = 0;
  // [7] Determines the state of the Data Set Ready line.
  virtual HRESULT STDMETHODCALLTYPE set_DSRHolding(VARIANT_BOOL pfDSRHolding/*[in]*/) = 0;
  // [7] Determines the state of the Data Set Ready line.
  virtual HRESULT STDMETHODCALLTYPE get_DSRHolding(VARIANT_BOOL* pfDSRHolding/*[out,retval]*/) = 0;
  // [8] Sets/returns the number of milliseconds to wait for the Data Set Ready.
  virtual HRESULT STDMETHODCALLTYPE set_DSRTimeout(long plDSRTimeout/*[in]*/) = 0;
  // [8] Sets/returns the number of milliseconds to wait for the Data Set Ready.
  virtual HRESULT STDMETHODCALLTYPE get_DSRTimeout(long* plDSRTimeout/*[out,retval]*/) = 0;
  // [9] Determines whether to enable the Data Terminal Ready line during communications.
  virtual HRESULT STDMETHODCALLTYPE set_DTREnable(VARIANT_BOOL pfDTREnable/*[in]*/) = 0;
  // [9] Determines whether to enable the Data Terminal Ready line during communications.
  virtual HRESULT STDMETHODCALLTYPE get_DTREnable(VARIANT_BOOL* pfDTREnable/*[out,retval]*/) = 0;
  // [10] Sets/returns the hardware handshaking protocol.
  virtual HRESULT STDMETHODCALLTYPE set_Handshaking(Mscommlib_tlb::HandshakeConstants phandshake/*[in]*/) = 0;
  // [10] Sets/returns the hardware handshaking protocol.
  virtual HRESULT STDMETHODCALLTYPE get_Handshaking(Mscommlib_tlb::HandshakeConstants* phandshake/*[out,retval]*/) = 0;
  // [11] Sets/returns the size of the receive buffer in bytes.
  virtual HRESULT STDMETHODCALLTYPE set_InBufferSize(short psInBufferSize/*[in]*/) = 0;
  // [11] Sets/returns the size of the receive buffer in bytes.
  virtual HRESULT STDMETHODCALLTYPE get_InBufferSize(short* psInBufferSize/*[out,retval]*/) = 0;
  // [12] Returns the number of characters waiting in the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE set_InBufferCount(short psInBufferCount/*[in]*/) = 0;
  // [12] Returns the number of characters waiting in the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE get_InBufferCount(short* psInBufferCount/*[out,retval]*/) = 0;
  // [13] Sets or clears the break signal state.
  virtual HRESULT STDMETHODCALLTYPE set_Break(VARIANT_BOOL pfBreak/*[in]*/) = 0;
  // [13] Sets or clears the break signal state.
  virtual HRESULT STDMETHODCALLTYPE get_Break(VARIANT_BOOL* pfBreak/*[out,retval]*/) = 0;
  // [14] Sets/returns the number of characters the Input property reads from the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE set_InputLen(short psInputLen/*[in]*/) = 0;
  // [14] Sets/returns the number of characters the Input property reads from the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE get_InputLen(short* psInputLen/*[out,retval]*/) = 0;
  // [15] Sets the interval, in milliseconds, for polling the hardware port for data under Windows version 3.0.
  virtual HRESULT STDMETHODCALLTYPE set_Interval(long plInterval/*[in]*/) = 0;
  // [15] Sets the interval, in milliseconds, for polling the hardware port for data under Windows version 3.0.
  virtual HRESULT STDMETHODCALLTYPE get_Interval(long* plInterval/*[out,retval]*/) = 0;
  // [16] Determines whether null characters are transferred from the port to the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE set_NullDiscard(VARIANT_BOOL pfNullDiscard/*[in]*/) = 0;
  // [16] Determines whether null characters are transferred from the port to the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE get_NullDiscard(VARIANT_BOOL* pfNullDiscard/*[out,retval]*/) = 0;
  // [17] Sets/returns the size, in characters, of the transmit buffer.
  virtual HRESULT STDMETHODCALLTYPE set_OutBufferSize(short psOutBufferSize/*[in]*/) = 0;
  // [17] Sets/returns the size, in characters, of the transmit buffer.
  virtual HRESULT STDMETHODCALLTYPE get_OutBufferSize(short* psOutBufferSize/*[out,retval]*/) = 0;
  // [18] Returns the number of characters waiting in the transmit buffer.
  virtual HRESULT STDMETHODCALLTYPE set_OutBufferCount(short psOutBufferCount/*[in]*/) = 0;
  // [18] Returns the number of characters waiting in the transmit buffer.
  virtual HRESULT STDMETHODCALLTYPE get_OutBufferCount(short* psOutBufferCount/*[out,retval]*/) = 0;
  // [19] Sets/returns the character that replaces an invalid character in the data stream when a parity error occurs.
  virtual HRESULT STDMETHODCALLTYPE set_ParityReplace(BSTR pbstrParityReplace/*[in]*/) = 0;
  // [19] Sets/returns the character that replaces an invalid character in the data stream when a parity error occurs.
  virtual HRESULT STDMETHODCALLTYPE get_ParityReplace(BSTR* pbstrParityReplace/*[out,retval]*/) = 0;
  // [20] Sets/returns the state of the communications port (open or closed).
  virtual HRESULT STDMETHODCALLTYPE set_PortOpen(VARIANT_BOOL pfPortOpen/*[in]*/) = 0;
  // [20] Sets/returns the state of the communications port (open or closed).
  virtual HRESULT STDMETHODCALLTYPE get_PortOpen(VARIANT_BOOL* pfPortOpen/*[out,retval]*/) = 0;
  // [21] Sets/returns the number of characters to receive.
  virtual HRESULT STDMETHODCALLTYPE set_RThreshold(short psRThreshold/*[in]*/) = 0;
  // [21] Sets/returns the number of characters to receive.
  virtual HRESULT STDMETHODCALLTYPE get_RThreshold(short* psRThreshold/*[out,retval]*/) = 0;
  // [22] Determines whether to enable the Request To Send line.
  virtual HRESULT STDMETHODCALLTYPE set_RTSEnable(VARIANT_BOOL pfRTSEnable/*[in]*/) = 0;
  // [22] Determines whether to enable the Request To Send line.
  virtual HRESULT STDMETHODCALLTYPE get_RTSEnable(VARIANT_BOOL* pfRTSEnable/*[out,retval]*/) = 0;
  // [23] Sets/returns the baud rate, parity, data bit, and stop bit parameters.
  virtual HRESULT STDMETHODCALLTYPE set_Settings(BSTR pbstrSettings/*[in]*/) = 0;
  // [23] Sets/returns the baud rate, parity, data bit, and stop bit parameters.
  virtual HRESULT STDMETHODCALLTYPE get_Settings(BSTR* pbstrSettings/*[out,retval]*/) = 0;
  // [24] Sets/returns the minimum number of characters allowable in the transmit.
  virtual HRESULT STDMETHODCALLTYPE set_SThreshold(short psSThreshold/*[in]*/) = 0;
  // [24] Sets/returns the minimum number of characters allowable in the transmit.
  virtual HRESULT STDMETHODCALLTYPE get_SThreshold(short* psSThreshold/*[out,retval]*/) = 0;
  // [25] Writes a string of characters to the transmit buffer.
  virtual HRESULT STDMETHODCALLTYPE set_Output(VARIANT pvarOutput/*[in]*/) = 0;
  // [25] Writes a string of characters to the transmit buffer.
  virtual HRESULT STDMETHODCALLTYPE get_Output(VARIANT* pvarOutput/*[out,retval]*/) = 0;
  // [26] Returns and removes a string of characters from the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE set_Input(VARIANT pvarInput/*[in]*/) = 0;
  // [26] Returns and removes a string of characters from the receive buffer.
  virtual HRESULT STDMETHODCALLTYPE get_Input(VARIANT* pvarInput/*[out,retval]*/) = 0;
  // [27] Returns the most recent communication event or error.
  virtual HRESULT STDMETHODCALLTYPE set_CommEvent(short psCommEvent/*[in]*/) = 0;
  // [27] Returns the most recent communication event or error.
  virtual HRESULT STDMETHODCALLTYPE get_CommEvent(short* psCommEvent/*[out,retval]*/) = 0;
  // [28] Sets/returns the whether to search for the EOF character.
  virtual HRESULT STDMETHODCALLTYPE set_EOFEnable(VARIANT_BOOL pfEOFEnable/*[in]*/) = 0;
  // [28] Sets/returns the whether to search for the EOF character.
  virtual HRESULT STDMETHODCALLTYPE get_EOFEnable(VARIANT_BOOL* pfEOFEnable/*[out,retval]*/) = 0;
  // [29] Sets/returns the type of data retrieved by the Input property.
  virtual HRESULT STDMETHODCALLTYPE set_InputMode(Mscommlib_tlb::InputModeConstants InputMode/*[in]*/) = 0;
  // [29] Sets/returns the type of data retrieved by the Input property.
  virtual HRESULT STDMETHODCALLTYPE get_InputMode(Mscommlib_tlb::InputModeConstants* InputMode/*[out,retval]*/) = 0;
  virtual void STDMETHODCALLTYPE AboutBox(void) = 0; // [-552]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  VARIANT_BOOL __fastcall get_CDHolding(void)
  {
    VARIANT_BOOL pfCDHolding;
    OLECHECK(this->get_CDHolding((VARIANT_BOOL*)&pfCDHolding));
    return pfCDHolding;
  }

  long __fastcall get_CDTimeout(void)
  {
    long plCDTimeout;
    OLECHECK(this->get_CDTimeout((long*)&plCDTimeout));
    return plCDTimeout;
  }

  long __fastcall get_CommID(void)
  {
    long plCommID;
    OLECHECK(this->get_CommID((long*)&plCommID));
    return plCommID;
  }

  short __fastcall get_CommPort(void)
  {
    short psCommPort;
    OLECHECK(this->get_CommPort((short*)&psCommPort));
    return psCommPort;
  }

  short __fastcall get__CommPort(void)
  {
    short psCommPort;
    OLECHECK(this->get__CommPort((short*)&psCommPort));
    return psCommPort;
  }

  VARIANT_BOOL __fastcall get_CTSHolding(void)
  {
    VARIANT_BOOL pfCTSHolding;
    OLECHECK(this->get_CTSHolding((VARIANT_BOOL*)&pfCTSHolding));
    return pfCTSHolding;
  }

  long __fastcall get_CTSTimeout(void)
  {
    long plCTSTimeout;
    OLECHECK(this->get_CTSTimeout((long*)&plCTSTimeout));
    return plCTSTimeout;
  }

  VARIANT_BOOL __fastcall get_DSRHolding(void)
  {
    VARIANT_BOOL pfDSRHolding;
    OLECHECK(this->get_DSRHolding((VARIANT_BOOL*)&pfDSRHolding));
    return pfDSRHolding;
  }

  long __fastcall get_DSRTimeout(void)
  {
    long plDSRTimeout;
    OLECHECK(this->get_DSRTimeout((long*)&plDSRTimeout));
    return plDSRTimeout;
  }

  VARIANT_BOOL __fastcall get_DTREnable(void)
  {
    VARIANT_BOOL pfDTREnable;
    OLECHECK(this->get_DTREnable((VARIANT_BOOL*)&pfDTREnable));
    return pfDTREnable;
  }

  Mscommlib_tlb::HandshakeConstants __fastcall get_Handshaking(void)
  {
    Mscommlib_tlb::HandshakeConstants phandshake;
    OLECHECK(this->get_Handshaking((Mscommlib_tlb::HandshakeConstants*)&phandshake));
    return phandshake;
  }

  short __fastcall get_InBufferSize(void)
  {
    short psInBufferSize;
    OLECHECK(this->get_InBufferSize((short*)&psInBufferSize));
    return psInBufferSize;
  }

  short __fastcall get_InBufferCount(void)
  {
    short psInBufferCount;
    OLECHECK(this->get_InBufferCount((short*)&psInBufferCount));
    return psInBufferCount;
  }

  VARIANT_BOOL __fastcall get_Break(void)
  {
    VARIANT_BOOL pfBreak;
    OLECHECK(this->get_Break((VARIANT_BOOL*)&pfBreak));
    return pfBreak;
  }

  short __fastcall get_InputLen(void)
  {
    short psInputLen;
    OLECHECK(this->get_InputLen((short*)&psInputLen));
    return psInputLen;
  }

  long __fastcall get_Interval(void)
  {
    long plInterval;
    OLECHECK(this->get_Interval((long*)&plInterval));
    return plInterval;
  }

  VARIANT_BOOL __fastcall get_NullDiscard(void)
  {
    VARIANT_BOOL pfNullDiscard;
    OLECHECK(this->get_NullDiscard((VARIANT_BOOL*)&pfNullDiscard));
    return pfNullDiscard;
  }

  short __fastcall get_OutBufferSize(void)
  {
    short psOutBufferSize;
    OLECHECK(this->get_OutBufferSize((short*)&psOutBufferSize));
    return psOutBufferSize;
  }

  short __fastcall get_OutBufferCount(void)
  {
    short psOutBufferCount;
    OLECHECK(this->get_OutBufferCount((short*)&psOutBufferCount));
    return psOutBufferCount;
  }

  BSTR __fastcall get_ParityReplace(void)
  {
    BSTR pbstrParityReplace = 0;
    OLECHECK(this->get_ParityReplace((BSTR*)&pbstrParityReplace));
    return pbstrParityReplace;
  }

  VARIANT_BOOL __fastcall get_PortOpen(void)
  {
    VARIANT_BOOL pfPortOpen;
    OLECHECK(this->get_PortOpen((VARIANT_BOOL*)&pfPortOpen));
    return pfPortOpen;
  }

  short __fastcall get_RThreshold(void)
  {
    short psRThreshold;
    OLECHECK(this->get_RThreshold((short*)&psRThreshold));
    return psRThreshold;
  }

  VARIANT_BOOL __fastcall get_RTSEnable(void)
  {
    VARIANT_BOOL pfRTSEnable;
    OLECHECK(this->get_RTSEnable((VARIANT_BOOL*)&pfRTSEnable));
    return pfRTSEnable;
  }

  BSTR __fastcall get_Settings(void)
  {
    BSTR pbstrSettings = 0;
    OLECHECK(this->get_Settings((BSTR*)&pbstrSettings));
    return pbstrSettings;
  }

  short __fastcall get_SThreshold(void)
  {
    short psSThreshold;
    OLECHECK(this->get_SThreshold((short*)&psSThreshold));
    return psSThreshold;
  }

  VARIANT __fastcall get_Output(void)
  {
    VARIANT pvarOutput;
    OLECHECK(this->get_Output((VARIANT*)&pvarOutput));
    return pvarOutput;
  }

  VARIANT __fastcall get_Input(void)
  {
    VARIANT pvarInput;
    OLECHECK(this->get_Input((VARIANT*)&pvarInput));
    return pvarInput;
  }

  short __fastcall get_CommEvent(void)
  {
    short psCommEvent;
    OLECHECK(this->get_CommEvent((short*)&psCommEvent));
    return psCommEvent;
  }

  VARIANT_BOOL __fastcall get_EOFEnable(void)
  {
    VARIANT_BOOL pfEOFEnable;
    OLECHECK(this->get_EOFEnable((VARIANT_BOOL*)&pfEOFEnable));
    return pfEOFEnable;
  }

  Mscommlib_tlb::InputModeConstants __fastcall get_InputMode(void)
  {
    Mscommlib_tlb::InputModeConstants InputMode;
    OLECHECK(this->get_InputMode((Mscommlib_tlb::InputModeConstants*)&InputMode));
    return InputMode;
  }


  __property   VARIANT_BOOL    CDHolding = {read = get_CDHolding, write = set_CDHolding};
  __property   long            CDTimeout = {read = get_CDTimeout, write = set_CDTimeout};
  __property   long            CommID = {read = get_CommID, write = set_CommID};
  __property   short           CommPort = {read = get_CommPort, write = set_CommPort};
  __property   short           _CommPort = {read = get__CommPort, write = set__CommPort};
  __property   VARIANT_BOOL    CTSHolding = {read = get_CTSHolding, write = set_CTSHolding};
  __property   long            CTSTimeout = {read = get_CTSTimeout, write = set_CTSTimeout};
  __property   VARIANT_BOOL    DSRHolding = {read = get_DSRHolding, write = set_DSRHolding};
  __property   long            DSRTimeout = {read = get_DSRTimeout, write = set_DSRTimeout};
  __property   VARIANT_BOOL    DTREnable = {read = get_DTREnable, write = set_DTREnable};
  __property   Mscommlib_tlb::HandshakeConstants Handshaking = {read = get_Handshaking, write = set_Handshaking};
  __property   short           InBufferSize = {read = get_InBufferSize, write = set_InBufferSize};
  __property   short           InBufferCount = {read = get_InBufferCount, write = set_InBufferCount};
  __property   VARIANT_BOOL    Break = {read = get_Break, write = set_Break};
  __property   short           InputLen = {read = get_InputLen, write = set_InputLen};
  __property   long            Interval = {read = get_Interval, write = set_Interval};
  __property   VARIANT_BOOL    NullDiscard = {read = get_NullDiscard, write = set_NullDiscard};
  __property   short           OutBufferSize = {read = get_OutBufferSize, write = set_OutBufferSize};
  __property   short           OutBufferCount = {read = get_OutBufferCount, write = set_OutBufferCount};
  __property   BSTR            ParityReplace = {read = get_ParityReplace, write = set_ParityReplace};
  __property   VARIANT_BOOL    PortOpen = {read = get_PortOpen, write = set_PortOpen};
  __property   short           RThreshold = {read = get_RThreshold, write = set_RThreshold};
  __property   VARIANT_BOOL    RTSEnable = {read = get_RTSEnable, write = set_RTSEnable};
  __property   BSTR            Settings = {read = get_Settings, write = set_Settings};
  __property   short           SThreshold = {read = get_SThreshold, write = set_SThreshold};
  __property   short           CommEvent = {read = get_CommEvent, write = set_CommEvent};
  __property   VARIANT_BOOL    EOFEnable = {read = get_EOFEnable, write = set_EOFEnable};
  __property   Mscommlib_tlb::InputModeConstants InputMode = {read = get_InputMode, write = set_InputMode};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: DMSCommEvents
// Flags:     (4112) Hidden Dispatchable
// GUID:      {648A5602-2C6E-101B-82B6-000000000014}
// *********************************************************************//
interface DMSCommEvents : public TDispWrapper<IDispatch>
{
  void __fastcall OnComm()
  {
    _TDispID _dispid(/* OnComm */ DISPID(1));
    OleProcedure(_dispid);
  }


};
#if !defined(__TLB_NO_INTERFACE_WRAPPERS)
// *********************************************************************//
// SmartIntf: TCOMIMSComm
// Interface: IMSComm
// *********************************************************************//
template <class T /* IMSComm */ >
class TCOMIMSCommT : public TComInterface<IMSComm>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMIMSCommT() {}
  TCOMIMSCommT(IMSComm *intf, bool addRef = false) : TComInterface<IMSComm>(intf, addRef) {}
  TCOMIMSCommT(const TCOMIMSCommT& src) : TComInterface<IMSComm>(src) {}
  TCOMIMSCommT& operator=(const TCOMIMSCommT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall set_CDHolding(VARIANT_BOOL pfCDHolding/*[in]*/);
  HRESULT         __fastcall set_CDHolding(TOLEBOOL pfCDHolding/*[in]*/);
  HRESULT         __fastcall get_CDHolding(VARIANT_BOOL* pfCDHolding/*[out,retval]*/);
  HRESULT         __fastcall get_CDHolding(TOLEBOOL* pfCDHolding/*[out,retval]*/);
  TOLEBOOL        __fastcall get_CDHolding(void);
  HRESULT         __fastcall set_CDTimeout(long plCDTimeout/*[in]*/);
  HRESULT         __fastcall get_CDTimeout(long* plCDTimeout/*[out,retval]*/);
  long            __fastcall get_CDTimeout(void);
  HRESULT         __fastcall set_CommID(long plCommID/*[in]*/);
  HRESULT         __fastcall get_CommID(long* plCommID/*[out,retval]*/);
  long            __fastcall get_CommID(void);
  HRESULT         __fastcall set_CommPort(short psCommPort/*[in]*/);
  HRESULT         __fastcall get_CommPort(short* psCommPort/*[out,retval]*/);
  short           __fastcall get_CommPort(void);
  HRESULT         __fastcall set__CommPort(short psCommPort/*[in]*/);
  HRESULT         __fastcall get__CommPort(short* psCommPort/*[out,retval]*/);
  short           __fastcall get__CommPort(void);
  HRESULT         __fastcall set_CTSHolding(VARIANT_BOOL pfCTSHolding/*[in]*/);
  HRESULT         __fastcall set_CTSHolding(TOLEBOOL pfCTSHolding/*[in]*/);
  HRESULT         __fastcall get_CTSHolding(VARIANT_BOOL* pfCTSHolding/*[out,retval]*/);
  HRESULT         __fastcall get_CTSHolding(TOLEBOOL* pfCTSHolding/*[out,retval]*/);
  TOLEBOOL        __fastcall get_CTSHolding(void);
  HRESULT         __fastcall set_CTSTimeout(long plCTSTimeout/*[in]*/);
  HRESULT         __fastcall get_CTSTimeout(long* plCTSTimeout/*[out,retval]*/);
  long            __fastcall get_CTSTimeout(void);
  HRESULT         __fastcall set_DSRHolding(VARIANT_BOOL pfDSRHolding/*[in]*/);
  HRESULT         __fastcall set_DSRHolding(TOLEBOOL pfDSRHolding/*[in]*/);
  HRESULT         __fastcall get_DSRHolding(VARIANT_BOOL* pfDSRHolding/*[out,retval]*/);
  HRESULT         __fastcall get_DSRHolding(TOLEBOOL* pfDSRHolding/*[out,retval]*/);
  TOLEBOOL        __fastcall get_DSRHolding(void);
  HRESULT         __fastcall set_DSRTimeout(long plDSRTimeout/*[in]*/);
  HRESULT         __fastcall get_DSRTimeout(long* plDSRTimeout/*[out,retval]*/);
  long            __fastcall get_DSRTimeout(void);
  HRESULT         __fastcall set_DTREnable(VARIANT_BOOL pfDTREnable/*[in]*/);
  HRESULT         __fastcall set_DTREnable(TOLEBOOL pfDTREnable/*[in]*/);
  HRESULT         __fastcall get_DTREnable(VARIANT_BOOL* pfDTREnable/*[out,retval]*/);
  HRESULT         __fastcall get_DTREnable(TOLEBOOL* pfDTREnable/*[out,retval]*/);
  TOLEBOOL        __fastcall get_DTREnable(void);
  HRESULT         __fastcall set_Handshaking(Mscommlib_tlb::HandshakeConstants phandshake/*[in]*/);
  HRESULT         __fastcall get_Handshaking(Mscommlib_tlb::HandshakeConstants* phandshake/*[out,retval]*/);
  Mscommlib_tlb::HandshakeConstants __fastcall get_Handshaking(void);
  HRESULT         __fastcall set_InBufferSize(short psInBufferSize/*[in]*/);
  HRESULT         __fastcall get_InBufferSize(short* psInBufferSize/*[out,retval]*/);
  short           __fastcall get_InBufferSize(void);
  HRESULT         __fastcall set_InBufferCount(short psInBufferCount/*[in]*/);
  HRESULT         __fastcall get_InBufferCount(short* psInBufferCount/*[out,retval]*/);
  short           __fastcall get_InBufferCount(void);
  HRESULT         __fastcall set_Break(VARIANT_BOOL pfBreak/*[in]*/);
  HRESULT         __fastcall set_Break(TOLEBOOL pfBreak/*[in]*/);
  HRESULT         __fastcall get_Break(VARIANT_BOOL* pfBreak/*[out,retval]*/);
  HRESULT         __fastcall get_Break(TOLEBOOL* pfBreak/*[out,retval]*/);
  TOLEBOOL        __fastcall get_Break(void);
  HRESULT         __fastcall set_InputLen(short psInputLen/*[in]*/);
  HRESULT         __fastcall get_InputLen(short* psInputLen/*[out,retval]*/);
  short           __fastcall get_InputLen(void);
  HRESULT         __fastcall set_Interval(long plInterval/*[in]*/);
  HRESULT         __fastcall get_Interval(long* plInterval/*[out,retval]*/);
  long            __fastcall get_Interval(void);
  HRESULT         __fastcall set_NullDiscard(VARIANT_BOOL pfNullDiscard/*[in]*/);
  HRESULT         __fastcall set_NullDiscard(TOLEBOOL pfNullDiscard/*[in]*/);
  HRESULT         __fastcall get_NullDiscard(VARIANT_BOOL* pfNullDiscard/*[out,retval]*/);
  HRESULT         __fastcall get_NullDiscard(TOLEBOOL* pfNullDiscard/*[out,retval]*/);
  TOLEBOOL        __fastcall get_NullDiscard(void);
  HRESULT         __fastcall set_OutBufferSize(short psOutBufferSize/*[in]*/);
  HRESULT         __fastcall get_OutBufferSize(short* psOutBufferSize/*[out,retval]*/);
  short           __fastcall get_OutBufferSize(void);
  HRESULT         __fastcall set_OutBufferCount(short psOutBufferCount/*[in]*/);
  HRESULT         __fastcall get_OutBufferCount(short* psOutBufferCount/*[out,retval]*/);
  short           __fastcall get_OutBufferCount(void);
  HRESULT         __fastcall set_ParityReplace(BSTR pbstrParityReplace/*[in]*/);
  HRESULT         __fastcall get_ParityReplace(BSTR* pbstrParityReplace/*[out,retval]*/);
  BSTR            __fastcall get_ParityReplace(void);
  HRESULT         __fastcall set_PortOpen(VARIANT_BOOL pfPortOpen/*[in]*/);
  HRESULT         __fastcall set_PortOpen(TOLEBOOL pfPortOpen/*[in]*/);
  HRESULT         __fastcall get_PortOpen(VARIANT_BOOL* pfPortOpen/*[out,retval]*/);
  HRESULT         __fastcall get_PortOpen(TOLEBOOL* pfPortOpen/*[out,retval]*/);
  TOLEBOOL        __fastcall get_PortOpen(void);
  HRESULT         __fastcall set_RThreshold(short psRThreshold/*[in]*/);
  HRESULT         __fastcall get_RThreshold(short* psRThreshold/*[out,retval]*/);
  short           __fastcall get_RThreshold(void);
  HRESULT         __fastcall set_RTSEnable(VARIANT_BOOL pfRTSEnable/*[in]*/);
  HRESULT         __fastcall set_RTSEnable(TOLEBOOL pfRTSEnable/*[in]*/);
  HRESULT         __fastcall get_RTSEnable(VARIANT_BOOL* pfRTSEnable/*[out,retval]*/);
  HRESULT         __fastcall get_RTSEnable(TOLEBOOL* pfRTSEnable/*[out,retval]*/);
  TOLEBOOL        __fastcall get_RTSEnable(void);
  HRESULT         __fastcall set_Settings(BSTR pbstrSettings/*[in]*/);
  HRESULT         __fastcall get_Settings(BSTR* pbstrSettings/*[out,retval]*/);
  BSTR            __fastcall get_Settings(void);
  HRESULT         __fastcall set_SThreshold(short psSThreshold/*[in]*/);
  HRESULT         __fastcall get_SThreshold(short* psSThreshold/*[out,retval]*/);
  short           __fastcall get_SThreshold(void);
  HRESULT         __fastcall set_Output(VARIANT pvarOutput/*[in]*/);
  HRESULT         __fastcall get_Output(VARIANT* pvarOutput/*[out,retval]*/);
  VARIANT         __fastcall get_Output(void);
  HRESULT         __fastcall set_Input(VARIANT pvarInput/*[in]*/);
  HRESULT         __fastcall get_Input(VARIANT* pvarInput/*[out,retval]*/);
  VARIANT         __fastcall get_Input(void);
  HRESULT         __fastcall set_CommEvent(short psCommEvent/*[in]*/);
  HRESULT         __fastcall get_CommEvent(short* psCommEvent/*[out,retval]*/);
  short           __fastcall get_CommEvent(void);
  HRESULT         __fastcall set_EOFEnable(VARIANT_BOOL pfEOFEnable/*[in]*/);
  HRESULT         __fastcall set_EOFEnable(TOLEBOOL pfEOFEnable/*[in]*/);
  HRESULT         __fastcall get_EOFEnable(VARIANT_BOOL* pfEOFEnable/*[out,retval]*/);
  HRESULT         __fastcall get_EOFEnable(TOLEBOOL* pfEOFEnable/*[out,retval]*/);
  TOLEBOOL        __fastcall get_EOFEnable(void);
  HRESULT         __fastcall set_InputMode(Mscommlib_tlb::InputModeConstants InputMode/*[in]*/);
  HRESULT         __fastcall get_InputMode(Mscommlib_tlb::InputModeConstants* InputMode/*[out,retval]*/);
  Mscommlib_tlb::InputModeConstants __fastcall get_InputMode(void);
  void            __fastcall AboutBox(void);

  __property   TOLEBOOL        CDHolding = {write = set_CDHolding};
  __property   long            CDTimeout = {read = get_CDTimeout, write = set_CDTimeout};
  __property   long            CommID = {read = get_CommID, write = set_CommID};
  __property   short           CommPort = {read = get_CommPort, write = set_CommPort};
  __property   short           _CommPort = {read = get__CommPort, write = set__CommPort};
  __property   TOLEBOOL        CTSHolding = {write = set_CTSHolding};
  __property   long            CTSTimeout = {read = get_CTSTimeout, write = set_CTSTimeout};
  __property   TOLEBOOL        DSRHolding = {write = set_DSRHolding};
  __property   long            DSRTimeout = {read = get_DSRTimeout, write = set_DSRTimeout};
  __property   TOLEBOOL        DTREnable = {write = set_DTREnable};
  __property   Mscommlib_tlb::HandshakeConstants Handshaking = {read = get_Handshaking, write = set_Handshaking};
  __property   short           InBufferSize = {read = get_InBufferSize, write = set_InBufferSize};
  __property   short           InBufferCount = {read = get_InBufferCount, write = set_InBufferCount};
  __property   TOLEBOOL        Break = {write = set_Break};
  __property   short           InputLen = {read = get_InputLen, write = set_InputLen};
  __property   long            Interval = {read = get_Interval, write = set_Interval};
  __property   TOLEBOOL        NullDiscard = {write = set_NullDiscard};
  __property   short           OutBufferSize = {read = get_OutBufferSize, write = set_OutBufferSize};
  __property   short           OutBufferCount = {read = get_OutBufferCount, write = set_OutBufferCount};
  __property   BSTR            ParityReplace = {read = get_ParityReplace, write = set_ParityReplace};
  __property   TOLEBOOL        PortOpen = {write = set_PortOpen};
  __property   short           RThreshold = {read = get_RThreshold, write = set_RThreshold};
  __property   TOLEBOOL        RTSEnable = {write = set_RTSEnable};
  __property   BSTR            Settings = {read = get_Settings, write = set_Settings};
  __property   short           SThreshold = {read = get_SThreshold, write = set_SThreshold};
  __property   short           CommEvent = {read = get_CommEvent, write = set_CommEvent};
  __property   TOLEBOOL        EOFEnable = {write = set_EOFEnable};
  __property   Mscommlib_tlb::InputModeConstants InputMode = {read = get_InputMode, write = set_InputMode};
};
typedef TCOMIMSCommT<IMSComm> TCOMIMSComm;

// *********************************************************************//
// DispIntf:  IMSComm
// Flags:     (4560) Hidden Dual NonExtensible OleAutomation Dispatchable
// GUID:      {E6E17E90-DF38-11CF-8E74-00A0C90F26F8}
// *********************************************************************//
template<class T>
class IMSCommDispT : public TAutoDriver<IMSComm>
{
public:
  IMSCommDispT(){}

  IMSCommDispT(IMSComm *pintf)
  {
    TAutoDriver<IMSComm>::Bind(pintf, false);
  }

  IMSCommDispT(IMSCommPtr pintf)
  {
    TAutoDriver<IMSComm>::Bind(pintf, true);
  }

  IMSCommDispT& operator=(IMSComm *pintf)
  {
    TAutoDriver<IMSComm>::Bind(pintf, false);
    return *this;
  }

  IMSCommDispT& operator=(IMSCommPtr pintf)
  {
    TAutoDriver<IMSComm>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_MSComm));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_MSComm);
  }

  HRESULT         __fastcall set_CDHolding(VARIANT_BOOL pfCDHolding/*[in]*/);
  HRESULT         __fastcall get_CDHolding(VARIANT_BOOL* pfCDHolding/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_CDHolding(void);
  HRESULT         __fastcall set_CDTimeout(long plCDTimeout/*[in]*/);
  HRESULT         __fastcall get_CDTimeout(long* plCDTimeout/*[out,retval]*/);
  long            __fastcall get_CDTimeout(void);
  HRESULT         __fastcall set_CommID(long plCommID/*[in]*/);
  HRESULT         __fastcall get_CommID(long* plCommID/*[out,retval]*/);
  long            __fastcall get_CommID(void);
  HRESULT         __fastcall set_CommPort(short psCommPort/*[in]*/);
  HRESULT         __fastcall get_CommPort(short* psCommPort/*[out,retval]*/);
  short           __fastcall get_CommPort(void);
  HRESULT         __fastcall set__CommPort(short psCommPort/*[in]*/);
  HRESULT         __fastcall get__CommPort(short* psCommPort/*[out,retval]*/);
  short           __fastcall get__CommPort(void);
  HRESULT         __fastcall set_CTSHolding(VARIANT_BOOL pfCTSHolding/*[in]*/);
  HRESULT         __fastcall get_CTSHolding(VARIANT_BOOL* pfCTSHolding/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_CTSHolding(void);
  HRESULT         __fastcall set_CTSTimeout(long plCTSTimeout/*[in]*/);
  HRESULT         __fastcall get_CTSTimeout(long* plCTSTimeout/*[out,retval]*/);
  long            __fastcall get_CTSTimeout(void);
  HRESULT         __fastcall set_DSRHolding(VARIANT_BOOL pfDSRHolding/*[in]*/);
  HRESULT         __fastcall get_DSRHolding(VARIANT_BOOL* pfDSRHolding/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_DSRHolding(void);
  HRESULT         __fastcall set_DSRTimeout(long plDSRTimeout/*[in]*/);
  HRESULT         __fastcall get_DSRTimeout(long* plDSRTimeout/*[out,retval]*/);
  long            __fastcall get_DSRTimeout(void);
  HRESULT         __fastcall set_DTREnable(VARIANT_BOOL pfDTREnable/*[in]*/);
  HRESULT         __fastcall get_DTREnable(VARIANT_BOOL* pfDTREnable/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_DTREnable(void);
  HRESULT         __fastcall set_Handshaking(Mscommlib_tlb::HandshakeConstants phandshake/*[in]*/);
  HRESULT         __fastcall get_Handshaking(Mscommlib_tlb::HandshakeConstants* phandshake/*[out,retval]*/);
  Mscommlib_tlb::HandshakeConstants __fastcall get_Handshaking(void);
  HRESULT         __fastcall set_InBufferSize(short psInBufferSize/*[in]*/);
  HRESULT         __fastcall get_InBufferSize(short* psInBufferSize/*[out,retval]*/);
  short           __fastcall get_InBufferSize(void);
  HRESULT         __fastcall set_InBufferCount(short psInBufferCount/*[in]*/);
  HRESULT         __fastcall get_InBufferCount(short* psInBufferCount/*[out,retval]*/);
  short           __fastcall get_InBufferCount(void);
  HRESULT         __fastcall set_Break(VARIANT_BOOL pfBreak/*[in]*/);
  HRESULT         __fastcall get_Break(VARIANT_BOOL* pfBreak/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_Break(void);
  HRESULT         __fastcall set_InputLen(short psInputLen/*[in]*/);
  HRESULT         __fastcall get_InputLen(short* psInputLen/*[out,retval]*/);
  short           __fastcall get_InputLen(void);
  HRESULT         __fastcall set_Interval(long plInterval/*[in]*/);
  HRESULT         __fastcall get_Interval(long* plInterval/*[out,retval]*/);
  long            __fastcall get_Interval(void);
  HRESULT         __fastcall set_NullDiscard(VARIANT_BOOL pfNullDiscard/*[in]*/);
  HRESULT         __fastcall get_NullDiscard(VARIANT_BOOL* pfNullDiscard/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_NullDiscard(void);
  HRESULT         __fastcall set_OutBufferSize(short psOutBufferSize/*[in]*/);
  HRESULT         __fastcall get_OutBufferSize(short* psOutBufferSize/*[out,retval]*/);
  short           __fastcall get_OutBufferSize(void);
  HRESULT         __fastcall set_OutBufferCount(short psOutBufferCount/*[in]*/);
  HRESULT         __fastcall get_OutBufferCount(short* psOutBufferCount/*[out,retval]*/);
  short           __fastcall get_OutBufferCount(void);
  HRESULT         __fastcall set_ParityReplace(BSTR pbstrParityReplace/*[in]*/);
  HRESULT         __fastcall get_ParityReplace(BSTR* pbstrParityReplace/*[out,retval]*/);
  BSTR            __fastcall get_ParityReplace(void);
  HRESULT         __fastcall set_PortOpen(VARIANT_BOOL pfPortOpen/*[in]*/);
  HRESULT         __fastcall get_PortOpen(VARIANT_BOOL* pfPortOpen/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_PortOpen(void);
  HRESULT         __fastcall set_RThreshold(short psRThreshold/*[in]*/);
  HRESULT         __fastcall get_RThreshold(short* psRThreshold/*[out,retval]*/);
  short           __fastcall get_RThreshold(void);
  HRESULT         __fastcall set_RTSEnable(VARIANT_BOOL pfRTSEnable/*[in]*/);
  HRESULT         __fastcall get_RTSEnable(VARIANT_BOOL* pfRTSEnable/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_RTSEnable(void);
  HRESULT         __fastcall set_Settings(BSTR pbstrSettings/*[in]*/);
  HRESULT         __fastcall get_Settings(BSTR* pbstrSettings/*[out,retval]*/);
  BSTR            __fastcall get_Settings(void);
  HRESULT         __fastcall set_SThreshold(short psSThreshold/*[in]*/);
  HRESULT         __fastcall get_SThreshold(short* psSThreshold/*[out,retval]*/);
  short           __fastcall get_SThreshold(void);
  HRESULT         __fastcall set_Output(VARIANT pvarOutput/*[in]*/);
  HRESULT         __fastcall get_Output(VARIANT* pvarOutput/*[out,retval]*/);
  VARIANT         __fastcall get_Output(void);
  HRESULT         __fastcall set_Input(VARIANT pvarInput/*[in]*/);
  HRESULT         __fastcall get_Input(VARIANT* pvarInput/*[out,retval]*/);
  VARIANT         __fastcall get_Input(void);
  HRESULT         __fastcall set_CommEvent(short psCommEvent/*[in]*/);
  HRESULT         __fastcall get_CommEvent(short* psCommEvent/*[out,retval]*/);
  short           __fastcall get_CommEvent(void);
  HRESULT         __fastcall set_EOFEnable(VARIANT_BOOL pfEOFEnable/*[in]*/);
  HRESULT         __fastcall get_EOFEnable(VARIANT_BOOL* pfEOFEnable/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_EOFEnable(void);
  HRESULT         __fastcall set_InputMode(Mscommlib_tlb::InputModeConstants InputMode/*[in]*/);
  HRESULT         __fastcall get_InputMode(Mscommlib_tlb::InputModeConstants* InputMode/*[out,retval]*/);
  Mscommlib_tlb::InputModeConstants __fastcall get_InputMode(void);
  void            __fastcall AboutBox();

  __property   VARIANT_BOOL    CDHolding = {read = get_CDHolding, write = set_CDHolding};
  __property   long            CDTimeout = {read = get_CDTimeout, write = set_CDTimeout};
  __property   long            CommID = {read = get_CommID, write = set_CommID};
  __property   short           CommPort = {read = get_CommPort, write = set_CommPort};
  __property   short           _CommPort = {read = get__CommPort, write = set__CommPort};
  __property   VARIANT_BOOL    CTSHolding = {read = get_CTSHolding, write = set_CTSHolding};
  __property   long            CTSTimeout = {read = get_CTSTimeout, write = set_CTSTimeout};
  __property   VARIANT_BOOL    DSRHolding = {read = get_DSRHolding, write = set_DSRHolding};
  __property   long            DSRTimeout = {read = get_DSRTimeout, write = set_DSRTimeout};
  __property   VARIANT_BOOL    DTREnable = {read = get_DTREnable, write = set_DTREnable};
  __property   Mscommlib_tlb::HandshakeConstants Handshaking = {read = get_Handshaking, write = set_Handshaking};
  __property   short           InBufferSize = {read = get_InBufferSize, write = set_InBufferSize};
  __property   short           InBufferCount = {read = get_InBufferCount, write = set_InBufferCount};
  __property   VARIANT_BOOL    Break = {read = get_Break, write = set_Break};
  __property   short           InputLen = {read = get_InputLen, write = set_InputLen};
  __property   long            Interval = {read = get_Interval, write = set_Interval};
  __property   VARIANT_BOOL    NullDiscard = {read = get_NullDiscard, write = set_NullDiscard};
  __property   short           OutBufferSize = {read = get_OutBufferSize, write = set_OutBufferSize};
  __property   short           OutBufferCount = {read = get_OutBufferCount, write = set_OutBufferCount};
  __property   BSTR            ParityReplace = {read = get_ParityReplace, write = set_ParityReplace};
  __property   VARIANT_BOOL    PortOpen = {read = get_PortOpen, write = set_PortOpen};
  __property   short           RThreshold = {read = get_RThreshold, write = set_RThreshold};
  __property   VARIANT_BOOL    RTSEnable = {read = get_RTSEnable, write = set_RTSEnable};
  __property   BSTR            Settings = {read = get_Settings, write = set_Settings};
  __property   short           SThreshold = {read = get_SThreshold, write = set_SThreshold};
  __property   short           CommEvent = {read = get_CommEvent, write = set_CommEvent};
  __property   VARIANT_BOOL    EOFEnable = {read = get_EOFEnable, write = set_EOFEnable};
  __property   Mscommlib_tlb::InputModeConstants InputMode = {read = get_InputMode, write = set_InputMode};
};
typedef IMSCommDispT<IMSComm> IMSCommDisp;

// *********************************************************************//
// DispIntf:  DMSCommEvents
// Flags:     (4112) Hidden Dispatchable
// GUID:      {648A5602-2C6E-101B-82B6-000000000014}
// *********************************************************************//
template <class T>
class DMSCommEventsDispT : public TAutoDriver<DMSCommEvents>
{
public:
  DMSCommEventsDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }

  void            __fastcall OnComm();

};
typedef DMSCommEventsDispT<DMSCommEvents> DMSCommEventsDisp;

// *********************************************************************//
// SmartIntf: TCOMIMSComm
// Interface: IMSComm
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CDHolding(VARIANT_BOOL pfCDHolding/*[in]*/)
{
  return (*this)->set_CDHolding(pfCDHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CDHolding(TOLEBOOL pfCDHolding/*[in]*/)
{
  return (*this)->set_CDHolding(VARIANT_BOOL)pfCDHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CDHolding(VARIANT_BOOL* pfCDHolding/*[out,retval]*/)
{
  return (*this)->get_CDHolding(pfCDHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CDHolding(TOLEBOOL* pfCDHolding/*[out,retval]*/)
{
  return (*this)->get_CDHolding(VARIANT_BOOL*)pfCDHolding);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_CDHolding(void)
{
  VARIANT_BOOL pfCDHolding;
  OLECHECK(this->get_CDHolding((VARIANT_BOOL*)&pfCDHolding));
  return (TOLEBOOL)pfCDHolding;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CDTimeout(long plCDTimeout/*[in]*/)
{
  return (*this)->set_CDTimeout(plCDTimeout);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CDTimeout(long* plCDTimeout/*[out,retval]*/)
{
  return (*this)->get_CDTimeout(plCDTimeout);
}

template <class T> long __fastcall
TCOMIMSCommT<T>::get_CDTimeout(void)
{
  long plCDTimeout;
  OLECHECK(this->get_CDTimeout((long*)&plCDTimeout));
  return plCDTimeout;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CommID(long plCommID/*[in]*/)
{
  return (*this)->set_CommID(plCommID);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CommID(long* plCommID/*[out,retval]*/)
{
  return (*this)->get_CommID(plCommID);
}

template <class T> long __fastcall
TCOMIMSCommT<T>::get_CommID(void)
{
  long plCommID;
  OLECHECK(this->get_CommID((long*)&plCommID));
  return plCommID;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CommPort(short psCommPort/*[in]*/)
{
  return (*this)->set_CommPort(psCommPort);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CommPort(short* psCommPort/*[out,retval]*/)
{
  return (*this)->get_CommPort(psCommPort);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_CommPort(void)
{
  short psCommPort;
  OLECHECK(this->get_CommPort((short*)&psCommPort));
  return psCommPort;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set__CommPort(short psCommPort/*[in]*/)
{
  return (*this)->set__CommPort(psCommPort);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get__CommPort(short* psCommPort/*[out,retval]*/)
{
  return (*this)->get__CommPort(psCommPort);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get__CommPort(void)
{
  short psCommPort;
  OLECHECK(this->get__CommPort((short*)&psCommPort));
  return psCommPort;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CTSHolding(VARIANT_BOOL pfCTSHolding/*[in]*/)
{
  return (*this)->set_CTSHolding(pfCTSHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CTSHolding(TOLEBOOL pfCTSHolding/*[in]*/)
{
  return (*this)->set_CTSHolding(VARIANT_BOOL)pfCTSHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CTSHolding(VARIANT_BOOL* pfCTSHolding/*[out,retval]*/)
{
  return (*this)->get_CTSHolding(pfCTSHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CTSHolding(TOLEBOOL* pfCTSHolding/*[out,retval]*/)
{
  return (*this)->get_CTSHolding(VARIANT_BOOL*)pfCTSHolding);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_CTSHolding(void)
{
  VARIANT_BOOL pfCTSHolding;
  OLECHECK(this->get_CTSHolding((VARIANT_BOOL*)&pfCTSHolding));
  return (TOLEBOOL)pfCTSHolding;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CTSTimeout(long plCTSTimeout/*[in]*/)
{
  return (*this)->set_CTSTimeout(plCTSTimeout);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CTSTimeout(long* plCTSTimeout/*[out,retval]*/)
{
  return (*this)->get_CTSTimeout(plCTSTimeout);
}

template <class T> long __fastcall
TCOMIMSCommT<T>::get_CTSTimeout(void)
{
  long plCTSTimeout;
  OLECHECK(this->get_CTSTimeout((long*)&plCTSTimeout));
  return plCTSTimeout;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_DSRHolding(VARIANT_BOOL pfDSRHolding/*[in]*/)
{
  return (*this)->set_DSRHolding(pfDSRHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_DSRHolding(TOLEBOOL pfDSRHolding/*[in]*/)
{
  return (*this)->set_DSRHolding(VARIANT_BOOL)pfDSRHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_DSRHolding(VARIANT_BOOL* pfDSRHolding/*[out,retval]*/)
{
  return (*this)->get_DSRHolding(pfDSRHolding);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_DSRHolding(TOLEBOOL* pfDSRHolding/*[out,retval]*/)
{
  return (*this)->get_DSRHolding(VARIANT_BOOL*)pfDSRHolding);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_DSRHolding(void)
{
  VARIANT_BOOL pfDSRHolding;
  OLECHECK(this->get_DSRHolding((VARIANT_BOOL*)&pfDSRHolding));
  return (TOLEBOOL)pfDSRHolding;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_DSRTimeout(long plDSRTimeout/*[in]*/)
{
  return (*this)->set_DSRTimeout(plDSRTimeout);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_DSRTimeout(long* plDSRTimeout/*[out,retval]*/)
{
  return (*this)->get_DSRTimeout(plDSRTimeout);
}

template <class T> long __fastcall
TCOMIMSCommT<T>::get_DSRTimeout(void)
{
  long plDSRTimeout;
  OLECHECK(this->get_DSRTimeout((long*)&plDSRTimeout));
  return plDSRTimeout;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_DTREnable(VARIANT_BOOL pfDTREnable/*[in]*/)
{
  return (*this)->set_DTREnable(pfDTREnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_DTREnable(TOLEBOOL pfDTREnable/*[in]*/)
{
  return (*this)->set_DTREnable(VARIANT_BOOL)pfDTREnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_DTREnable(VARIANT_BOOL* pfDTREnable/*[out,retval]*/)
{
  return (*this)->get_DTREnable(pfDTREnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_DTREnable(TOLEBOOL* pfDTREnable/*[out,retval]*/)
{
  return (*this)->get_DTREnable(VARIANT_BOOL*)pfDTREnable);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_DTREnable(void)
{
  VARIANT_BOOL pfDTREnable;
  OLECHECK(this->get_DTREnable((VARIANT_BOOL*)&pfDTREnable));
  return (TOLEBOOL)pfDTREnable;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_Handshaking(Mscommlib_tlb::HandshakeConstants phandshake/*[in]*/)
{
  return (*this)->set_Handshaking(phandshake);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_Handshaking(Mscommlib_tlb::HandshakeConstants* phandshake/*[out,retval]*/)
{
  return (*this)->get_Handshaking(phandshake);
}

template <class T> Mscommlib_tlb::HandshakeConstants __fastcall
TCOMIMSCommT<T>::get_Handshaking(void)
{
  Mscommlib_tlb::HandshakeConstants phandshake;
  OLECHECK(this->get_Handshaking((Mscommlib_tlb::HandshakeConstants*)&phandshake));
  return phandshake;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_InBufferSize(short psInBufferSize/*[in]*/)
{
  return (*this)->set_InBufferSize(psInBufferSize);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_InBufferSize(short* psInBufferSize/*[out,retval]*/)
{
  return (*this)->get_InBufferSize(psInBufferSize);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_InBufferSize(void)
{
  short psInBufferSize;
  OLECHECK(this->get_InBufferSize((short*)&psInBufferSize));
  return psInBufferSize;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_InBufferCount(short psInBufferCount/*[in]*/)
{
  return (*this)->set_InBufferCount(psInBufferCount);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_InBufferCount(short* psInBufferCount/*[out,retval]*/)
{
  return (*this)->get_InBufferCount(psInBufferCount);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_InBufferCount(void)
{
  short psInBufferCount;
  OLECHECK(this->get_InBufferCount((short*)&psInBufferCount));
  return psInBufferCount;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_Break(VARIANT_BOOL pfBreak/*[in]*/)
{
  return (*this)->set_Break(pfBreak);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_Break(TOLEBOOL pfBreak/*[in]*/)
{
  return (*this)->set_Break(VARIANT_BOOL)pfBreak);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_Break(VARIANT_BOOL* pfBreak/*[out,retval]*/)
{
  return (*this)->get_Break(pfBreak);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_Break(TOLEBOOL* pfBreak/*[out,retval]*/)
{
  return (*this)->get_Break(VARIANT_BOOL*)pfBreak);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_Break(void)
{
  VARIANT_BOOL pfBreak;
  OLECHECK(this->get_Break((VARIANT_BOOL*)&pfBreak));
  return (TOLEBOOL)pfBreak;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_InputLen(short psInputLen/*[in]*/)
{
  return (*this)->set_InputLen(psInputLen);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_InputLen(short* psInputLen/*[out,retval]*/)
{
  return (*this)->get_InputLen(psInputLen);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_InputLen(void)
{
  short psInputLen;
  OLECHECK(this->get_InputLen((short*)&psInputLen));
  return psInputLen;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_Interval(long plInterval/*[in]*/)
{
  return (*this)->set_Interval(plInterval);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_Interval(long* plInterval/*[out,retval]*/)
{
  return (*this)->get_Interval(plInterval);
}

template <class T> long __fastcall
TCOMIMSCommT<T>::get_Interval(void)
{
  long plInterval;
  OLECHECK(this->get_Interval((long*)&plInterval));
  return plInterval;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_NullDiscard(VARIANT_BOOL pfNullDiscard/*[in]*/)
{
  return (*this)->set_NullDiscard(pfNullDiscard);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_NullDiscard(TOLEBOOL pfNullDiscard/*[in]*/)
{
  return (*this)->set_NullDiscard(VARIANT_BOOL)pfNullDiscard);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_NullDiscard(VARIANT_BOOL* pfNullDiscard/*[out,retval]*/)
{
  return (*this)->get_NullDiscard(pfNullDiscard);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_NullDiscard(TOLEBOOL* pfNullDiscard/*[out,retval]*/)
{
  return (*this)->get_NullDiscard(VARIANT_BOOL*)pfNullDiscard);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_NullDiscard(void)
{
  VARIANT_BOOL pfNullDiscard;
  OLECHECK(this->get_NullDiscard((VARIANT_BOOL*)&pfNullDiscard));
  return (TOLEBOOL)pfNullDiscard;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_OutBufferSize(short psOutBufferSize/*[in]*/)
{
  return (*this)->set_OutBufferSize(psOutBufferSize);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_OutBufferSize(short* psOutBufferSize/*[out,retval]*/)
{
  return (*this)->get_OutBufferSize(psOutBufferSize);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_OutBufferSize(void)
{
  short psOutBufferSize;
  OLECHECK(this->get_OutBufferSize((short*)&psOutBufferSize));
  return psOutBufferSize;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_OutBufferCount(short psOutBufferCount/*[in]*/)
{
  return (*this)->set_OutBufferCount(psOutBufferCount);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_OutBufferCount(short* psOutBufferCount/*[out,retval]*/)
{
  return (*this)->get_OutBufferCount(psOutBufferCount);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_OutBufferCount(void)
{
  short psOutBufferCount;
  OLECHECK(this->get_OutBufferCount((short*)&psOutBufferCount));
  return psOutBufferCount;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_ParityReplace(BSTR pbstrParityReplace/*[in]*/)
{
  return (*this)->set_ParityReplace(pbstrParityReplace);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_ParityReplace(BSTR* pbstrParityReplace/*[out,retval]*/)
{
  return (*this)->get_ParityReplace(pbstrParityReplace);
}

template <class T> BSTR __fastcall
TCOMIMSCommT<T>::get_ParityReplace(void)
{
  BSTR pbstrParityReplace = 0;
  OLECHECK(this->get_ParityReplace((BSTR*)&pbstrParityReplace));
  return pbstrParityReplace;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_PortOpen(VARIANT_BOOL pfPortOpen/*[in]*/)
{
  return (*this)->set_PortOpen(pfPortOpen);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_PortOpen(TOLEBOOL pfPortOpen/*[in]*/)
{
  return (*this)->set_PortOpen(VARIANT_BOOL)pfPortOpen);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_PortOpen(VARIANT_BOOL* pfPortOpen/*[out,retval]*/)
{
  return (*this)->get_PortOpen(pfPortOpen);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_PortOpen(TOLEBOOL* pfPortOpen/*[out,retval]*/)
{
  return (*this)->get_PortOpen(VARIANT_BOOL*)pfPortOpen);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_PortOpen(void)
{
  VARIANT_BOOL pfPortOpen;
  OLECHECK(this->get_PortOpen((VARIANT_BOOL*)&pfPortOpen));
  return (TOLEBOOL)pfPortOpen;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_RThreshold(short psRThreshold/*[in]*/)
{
  return (*this)->set_RThreshold(psRThreshold);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_RThreshold(short* psRThreshold/*[out,retval]*/)
{
  return (*this)->get_RThreshold(psRThreshold);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_RThreshold(void)
{
  short psRThreshold;
  OLECHECK(this->get_RThreshold((short*)&psRThreshold));
  return psRThreshold;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_RTSEnable(VARIANT_BOOL pfRTSEnable/*[in]*/)
{
  return (*this)->set_RTSEnable(pfRTSEnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_RTSEnable(TOLEBOOL pfRTSEnable/*[in]*/)
{
  return (*this)->set_RTSEnable(VARIANT_BOOL)pfRTSEnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_RTSEnable(VARIANT_BOOL* pfRTSEnable/*[out,retval]*/)
{
  return (*this)->get_RTSEnable(pfRTSEnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_RTSEnable(TOLEBOOL* pfRTSEnable/*[out,retval]*/)
{
  return (*this)->get_RTSEnable(VARIANT_BOOL*)pfRTSEnable);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_RTSEnable(void)
{
  VARIANT_BOOL pfRTSEnable;
  OLECHECK(this->get_RTSEnable((VARIANT_BOOL*)&pfRTSEnable));
  return (TOLEBOOL)pfRTSEnable;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_Settings(BSTR pbstrSettings/*[in]*/)
{
  return (*this)->set_Settings(pbstrSettings);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_Settings(BSTR* pbstrSettings/*[out,retval]*/)
{
  return (*this)->get_Settings(pbstrSettings);
}

template <class T> BSTR __fastcall
TCOMIMSCommT<T>::get_Settings(void)
{
  BSTR pbstrSettings = 0;
  OLECHECK(this->get_Settings((BSTR*)&pbstrSettings));
  return pbstrSettings;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_SThreshold(short psSThreshold/*[in]*/)
{
  return (*this)->set_SThreshold(psSThreshold);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_SThreshold(short* psSThreshold/*[out,retval]*/)
{
  return (*this)->get_SThreshold(psSThreshold);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_SThreshold(void)
{
  short psSThreshold;
  OLECHECK(this->get_SThreshold((short*)&psSThreshold));
  return psSThreshold;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_Output(VARIANT pvarOutput/*[in]*/)
{
  return (*this)->set_Output(pvarOutput);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_Output(VARIANT* pvarOutput/*[out,retval]*/)
{
  return (*this)->get_Output(pvarOutput);
}

template <class T> VARIANT __fastcall
TCOMIMSCommT<T>::get_Output(void)
{
  VARIANT pvarOutput;
  OLECHECK(this->get_Output((VARIANT*)&pvarOutput));
  return pvarOutput;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_Input(VARIANT pvarInput/*[in]*/)
{
  return (*this)->set_Input(pvarInput);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_Input(VARIANT* pvarInput/*[out,retval]*/)
{
  return (*this)->get_Input(pvarInput);
}

template <class T> VARIANT __fastcall
TCOMIMSCommT<T>::get_Input(void)
{
  VARIANT pvarInput;
  OLECHECK(this->get_Input((VARIANT*)&pvarInput));
  return pvarInput;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_CommEvent(short psCommEvent/*[in]*/)
{
  return (*this)->set_CommEvent(psCommEvent);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_CommEvent(short* psCommEvent/*[out,retval]*/)
{
  return (*this)->get_CommEvent(psCommEvent);
}

template <class T> short __fastcall
TCOMIMSCommT<T>::get_CommEvent(void)
{
  short psCommEvent;
  OLECHECK(this->get_CommEvent((short*)&psCommEvent));
  return psCommEvent;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_EOFEnable(VARIANT_BOOL pfEOFEnable/*[in]*/)
{
  return (*this)->set_EOFEnable(pfEOFEnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_EOFEnable(TOLEBOOL pfEOFEnable/*[in]*/)
{
  return (*this)->set_EOFEnable(VARIANT_BOOL)pfEOFEnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_EOFEnable(VARIANT_BOOL* pfEOFEnable/*[out,retval]*/)
{
  return (*this)->get_EOFEnable(pfEOFEnable);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_EOFEnable(TOLEBOOL* pfEOFEnable/*[out,retval]*/)
{
  return (*this)->get_EOFEnable(VARIANT_BOOL*)pfEOFEnable);
}

template <class T> TOLEBOOL __fastcall
TCOMIMSCommT<T>::get_EOFEnable(void)
{
  VARIANT_BOOL pfEOFEnable;
  OLECHECK(this->get_EOFEnable((VARIANT_BOOL*)&pfEOFEnable));
  return (TOLEBOOL)pfEOFEnable;
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::set_InputMode(Mscommlib_tlb::InputModeConstants InputMode/*[in]*/)
{
  return (*this)->set_InputMode(InputMode);
}

template <class T> HRESULT __fastcall
TCOMIMSCommT<T>::get_InputMode(Mscommlib_tlb::InputModeConstants* InputMode/*[out,retval]*/)
{
  return (*this)->get_InputMode(InputMode);
}

template <class T> Mscommlib_tlb::InputModeConstants __fastcall
TCOMIMSCommT<T>::get_InputMode(void)
{
  Mscommlib_tlb::InputModeConstants InputMode;
  OLECHECK(this->get_InputMode((Mscommlib_tlb::InputModeConstants*)&InputMode));
  return InputMode;
}

template <class T> void __fastcall
TCOMIMSCommT<T>::AboutBox(void)
{
  (*this)->AboutBox();
}

// *********************************************************************//
// DispIntf:  IMSComm
// Flags:     (4560) Hidden Dual NonExtensible OleAutomation Dispatchable
// GUID:      {E6E17E90-DF38-11CF-8E74-00A0C90F26F8}
// *********************************************************************//
template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_CDHolding(VARIANT_BOOL pfCDHolding/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CDHolding"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = pfCDHolding /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_CDHolding(VARIANT_BOOL* pfCDHolding/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CDHolding"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfCDHolding /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_CDHolding(void)
{
  VARIANT_BOOL pfCDHolding;
  this->get_CDHolding((VARIANT_BOOL*)&pfCDHolding);
  return pfCDHolding;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_CDTimeout(long plCDTimeout/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CDTimeout"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = plCDTimeout /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_CDTimeout(long* plCDTimeout/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CDTimeout"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(plCDTimeout /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
IMSCommDispT<T>::get_CDTimeout(void)
{
  long plCDTimeout;
  this->get_CDTimeout((long*)&plCDTimeout);
  return plCDTimeout;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_CommID(long plCommID/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CommID"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = plCommID /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_CommID(long* plCommID/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CommID"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(plCommID /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
IMSCommDispT<T>::get_CommID(void)
{
  long plCommID;
  this->get_CommID((long*)&plCommID);
  return plCommID;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_CommPort(short psCommPort/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CommPort"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = psCommPort /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_CommPort(short* psCommPort/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CommPort"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psCommPort /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_CommPort(void)
{
  short psCommPort;
  this->get_CommPort((short*)&psCommPort);
  return psCommPort;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set__CommPort(short psCommPort/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("_CommPort"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = psCommPort /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get__CommPort(short* psCommPort/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_CommPort"), DISPID(0));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psCommPort /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get__CommPort(void)
{
  short psCommPort;
  this->get__CommPort((short*)&psCommPort);
  return psCommPort;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_CTSHolding(VARIANT_BOOL pfCTSHolding/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CTSHolding"), DISPID(5));
  TAutoArgs<1> _args;
  _args[1] = pfCTSHolding /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_CTSHolding(VARIANT_BOOL* pfCTSHolding/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CTSHolding"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfCTSHolding /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_CTSHolding(void)
{
  VARIANT_BOOL pfCTSHolding;
  this->get_CTSHolding((VARIANT_BOOL*)&pfCTSHolding);
  return pfCTSHolding;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_CTSTimeout(long plCTSTimeout/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CTSTimeout"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = plCTSTimeout /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_CTSTimeout(long* plCTSTimeout/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CTSTimeout"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(plCTSTimeout /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
IMSCommDispT<T>::get_CTSTimeout(void)
{
  long plCTSTimeout;
  this->get_CTSTimeout((long*)&plCTSTimeout);
  return plCTSTimeout;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_DSRHolding(VARIANT_BOOL pfDSRHolding/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DSRHolding"), DISPID(7));
  TAutoArgs<1> _args;
  _args[1] = pfDSRHolding /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_DSRHolding(VARIANT_BOOL* pfDSRHolding/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DSRHolding"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfDSRHolding /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_DSRHolding(void)
{
  VARIANT_BOOL pfDSRHolding;
  this->get_DSRHolding((VARIANT_BOOL*)&pfDSRHolding);
  return pfDSRHolding;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_DSRTimeout(long plDSRTimeout/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DSRTimeout"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = plDSRTimeout /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_DSRTimeout(long* plDSRTimeout/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DSRTimeout"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(plDSRTimeout /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
IMSCommDispT<T>::get_DSRTimeout(void)
{
  long plDSRTimeout;
  this->get_DSRTimeout((long*)&plDSRTimeout);
  return plDSRTimeout;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_DTREnable(VARIANT_BOOL pfDTREnable/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DTREnable"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = pfDTREnable /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_DTREnable(VARIANT_BOOL* pfDTREnable/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DTREnable"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfDTREnable /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_DTREnable(void)
{
  VARIANT_BOOL pfDTREnable;
  this->get_DTREnable((VARIANT_BOOL*)&pfDTREnable);
  return pfDTREnable;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_Handshaking(Mscommlib_tlb::HandshakeConstants phandshake/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Handshaking"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = (int)phandshake /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_Handshaking(Mscommlib_tlb::HandshakeConstants* phandshake/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Handshaking"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)phandshake /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Mscommlib_tlb::HandshakeConstants __fastcall
IMSCommDispT<T>::get_Handshaking(void)
{
  Mscommlib_tlb::HandshakeConstants phandshake;
  this->get_Handshaking((Mscommlib_tlb::HandshakeConstants*)&phandshake);
  return phandshake;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_InBufferSize(short psInBufferSize/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("InBufferSize"), DISPID(11));
  TAutoArgs<1> _args;
  _args[1] = psInBufferSize /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_InBufferSize(short* psInBufferSize/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InBufferSize"), DISPID(11));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psInBufferSize /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_InBufferSize(void)
{
  short psInBufferSize;
  this->get_InBufferSize((short*)&psInBufferSize);
  return psInBufferSize;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_InBufferCount(short psInBufferCount/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("InBufferCount"), DISPID(12));
  TAutoArgs<1> _args;
  _args[1] = psInBufferCount /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_InBufferCount(short* psInBufferCount/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InBufferCount"), DISPID(12));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psInBufferCount /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_InBufferCount(void)
{
  short psInBufferCount;
  this->get_InBufferCount((short*)&psInBufferCount);
  return psInBufferCount;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_Break(VARIANT_BOOL pfBreak/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Break"), DISPID(13));
  TAutoArgs<1> _args;
  _args[1] = pfBreak /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_Break(VARIANT_BOOL* pfBreak/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Break"), DISPID(13));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfBreak /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_Break(void)
{
  VARIANT_BOOL pfBreak;
  this->get_Break((VARIANT_BOOL*)&pfBreak);
  return pfBreak;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_InputLen(short psInputLen/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputLen"), DISPID(14));
  TAutoArgs<1> _args;
  _args[1] = psInputLen /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_InputLen(short* psInputLen/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputLen"), DISPID(14));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psInputLen /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_InputLen(void)
{
  short psInputLen;
  this->get_InputLen((short*)&psInputLen);
  return psInputLen;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_Interval(long plInterval/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Interval"), DISPID(15));
  TAutoArgs<1> _args;
  _args[1] = plInterval /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_Interval(long* plInterval/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Interval"), DISPID(15));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(plInterval /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
IMSCommDispT<T>::get_Interval(void)
{
  long plInterval;
  this->get_Interval((long*)&plInterval);
  return plInterval;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_NullDiscard(VARIANT_BOOL pfNullDiscard/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("NullDiscard"), DISPID(16));
  TAutoArgs<1> _args;
  _args[1] = pfNullDiscard /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_NullDiscard(VARIANT_BOOL* pfNullDiscard/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NullDiscard"), DISPID(16));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfNullDiscard /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_NullDiscard(void)
{
  VARIANT_BOOL pfNullDiscard;
  this->get_NullDiscard((VARIANT_BOOL*)&pfNullDiscard);
  return pfNullDiscard;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_OutBufferSize(short psOutBufferSize/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("OutBufferSize"), DISPID(17));
  TAutoArgs<1> _args;
  _args[1] = psOutBufferSize /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_OutBufferSize(short* psOutBufferSize/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("OutBufferSize"), DISPID(17));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psOutBufferSize /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_OutBufferSize(void)
{
  short psOutBufferSize;
  this->get_OutBufferSize((short*)&psOutBufferSize);
  return psOutBufferSize;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_OutBufferCount(short psOutBufferCount/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("OutBufferCount"), DISPID(18));
  TAutoArgs<1> _args;
  _args[1] = psOutBufferCount /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_OutBufferCount(short* psOutBufferCount/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("OutBufferCount"), DISPID(18));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psOutBufferCount /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_OutBufferCount(void)
{
  short psOutBufferCount;
  this->get_OutBufferCount((short*)&psOutBufferCount);
  return psOutBufferCount;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_ParityReplace(BSTR pbstrParityReplace/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ParityReplace"), DISPID(19));
  TAutoArgs<1> _args;
  _args[1] = pbstrParityReplace /*[VT_BSTR:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_ParityReplace(BSTR* pbstrParityReplace/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ParityReplace"), DISPID(19));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pbstrParityReplace /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
IMSCommDispT<T>::get_ParityReplace(void)
{
  BSTR pbstrParityReplace;
  this->get_ParityReplace((BSTR*)&pbstrParityReplace);
  return pbstrParityReplace;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_PortOpen(VARIANT_BOOL pfPortOpen/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("PortOpen"), DISPID(20));
  TAutoArgs<1> _args;
  _args[1] = pfPortOpen /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_PortOpen(VARIANT_BOOL* pfPortOpen/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PortOpen"), DISPID(20));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfPortOpen /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_PortOpen(void)
{
  VARIANT_BOOL pfPortOpen;
  this->get_PortOpen((VARIANT_BOOL*)&pfPortOpen);
  return pfPortOpen;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_RThreshold(short psRThreshold/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RThreshold"), DISPID(21));
  TAutoArgs<1> _args;
  _args[1] = psRThreshold /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_RThreshold(short* psRThreshold/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RThreshold"), DISPID(21));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psRThreshold /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_RThreshold(void)
{
  short psRThreshold;
  this->get_RThreshold((short*)&psRThreshold);
  return psRThreshold;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_RTSEnable(VARIANT_BOOL pfRTSEnable/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RTSEnable"), DISPID(22));
  TAutoArgs<1> _args;
  _args[1] = pfRTSEnable /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_RTSEnable(VARIANT_BOOL* pfRTSEnable/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RTSEnable"), DISPID(22));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfRTSEnable /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_RTSEnable(void)
{
  VARIANT_BOOL pfRTSEnable;
  this->get_RTSEnable((VARIANT_BOOL*)&pfRTSEnable);
  return pfRTSEnable;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_Settings(BSTR pbstrSettings/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Settings"), DISPID(23));
  TAutoArgs<1> _args;
  _args[1] = pbstrSettings /*[VT_BSTR:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_Settings(BSTR* pbstrSettings/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Settings"), DISPID(23));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pbstrSettings /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
IMSCommDispT<T>::get_Settings(void)
{
  BSTR pbstrSettings;
  this->get_Settings((BSTR*)&pbstrSettings);
  return pbstrSettings;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_SThreshold(short psSThreshold/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SThreshold"), DISPID(24));
  TAutoArgs<1> _args;
  _args[1] = psSThreshold /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_SThreshold(short* psSThreshold/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SThreshold"), DISPID(24));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psSThreshold /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_SThreshold(void)
{
  short psSThreshold;
  this->get_SThreshold((short*)&psSThreshold);
  return psSThreshold;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_Output(VARIANT pvarOutput/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Output"), DISPID(25));
  TAutoArgs<1> _args;
  _args[1] = pvarOutput /*[VT_VARIANT:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_Output(VARIANT* pvarOutput/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Output"), DISPID(25));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pvarOutput /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
IMSCommDispT<T>::get_Output(void)
{
  VARIANT pvarOutput;
  this->get_Output((VARIANT*)&pvarOutput);
  return pvarOutput;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_Input(VARIANT pvarInput/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Input"), DISPID(26));
  TAutoArgs<1> _args;
  _args[1] = pvarInput /*[VT_VARIANT:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_Input(VARIANT* pvarInput/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Input"), DISPID(26));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pvarInput /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
IMSCommDispT<T>::get_Input(void)
{
  VARIANT pvarInput;
  this->get_Input((VARIANT*)&pvarInput);
  return pvarInput;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_CommEvent(short psCommEvent/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CommEvent"), DISPID(27));
  TAutoArgs<1> _args;
  _args[1] = psCommEvent /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_CommEvent(short* psCommEvent/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CommEvent"), DISPID(27));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(psCommEvent /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
IMSCommDispT<T>::get_CommEvent(void)
{
  short psCommEvent;
  this->get_CommEvent((short*)&psCommEvent);
  return psCommEvent;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_EOFEnable(VARIANT_BOOL pfEOFEnable/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("EOFEnable"), DISPID(28));
  TAutoArgs<1> _args;
  _args[1] = pfEOFEnable /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_EOFEnable(VARIANT_BOOL* pfEOFEnable/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EOFEnable"), DISPID(28));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pfEOFEnable /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IMSCommDispT<T>::get_EOFEnable(void)
{
  VARIANT_BOOL pfEOFEnable;
  this->get_EOFEnable((VARIANT_BOOL*)&pfEOFEnable);
  return pfEOFEnable;
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::set_InputMode(Mscommlib_tlb::InputModeConstants InputMode/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputMode"), DISPID(29));
  TAutoArgs<1> _args;
  _args[1] = (int)InputMode /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IMSCommDispT<T>::get_InputMode(Mscommlib_tlb::InputModeConstants* InputMode/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputMode"), DISPID(29));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)InputMode /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Mscommlib_tlb::InputModeConstants __fastcall
IMSCommDispT<T>::get_InputMode(void)
{
  Mscommlib_tlb::InputModeConstants InputMode;
  this->get_InputMode((Mscommlib_tlb::InputModeConstants*)&InputMode);
  return InputMode;
}

template <class T> void __fastcall
IMSCommDispT<T>::AboutBox()
{
  _TDispID _dispid(*this, OLETEXT("AboutBox"), DISPID(-552));
  OleProcedure(_dispid);
}

// *********************************************************************//
// DispIntf:  DMSCommEvents
// Flags:     (4112) Hidden Dispatchable
// GUID:      {648A5602-2C6E-101B-82B6-000000000014}
// *********************************************************************//
template <class T> void __fastcall
DMSCommEventsDispT<T>::OnComm()
{
  _TDispID _dispid(/* OnComm */ DISPID(1));
  OleProcedure(_dispid);
}

#endif  //   __TLB_NO_INTERFACE_WRAPPERS


#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_ATLVCL)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : MSComm
// Event Interface : DMSCommEvents
// *********************************************************************//
template <class T>
class TEvents_MSComm : public IConnectionPointImpl<T,
                                                 &DIID_DMSCommEvents,
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
 /* Note: if encountering problems with events, please change CComUnkArray to CComDynamicUnkArray in the line above. */
{
public:
  void            Fire_OnComm(void);
protected:
  DMSCommEventsDisp m_EventIntfObj;
};

template <class T> void
TEvents_MSComm<T>::Fire_OnComm(void)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnComm();
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

#endif  //   __TLB_NO_EVENT_WRAPPERS

};     // namespace Mscommlib_tlb

#if !defined(NO_IMPLICIT_NAMESPACE_USE)
using  namespace Mscommlib_tlb;
#endif

#pragma option pop

#endif // MSCommLib_TLBH
